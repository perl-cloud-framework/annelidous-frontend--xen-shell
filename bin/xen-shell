#!/usr/bin/perl -w

=head1 NAME

cloud-shell - Provide a console interface to control instances.

=cut


=head1 SYNOPSIS

  cloud-shell [options]

  Options:

   --control    Specify which instance to control by default.
   --help       Show brief help intstructions.
   --manual     Show more complete help.
   --version    Show the version of the software.

=cut


=head1 DESCRIPTION

  cloud-shell provides a simple console interface to allow a user to
 control a Xen instances which are running upon the local system.

  The shell features include:

=over 8

=item Command line completion

=item Command history

=item The ability to run within GNU Screen to allow long-running jobs to be completed "offline".

=back


=cut


=head1 XEN SETUP

  There are two ways to setup a instance which might be controlled by
 the local user "bob".

  The simplest method is to give a Xen instance the name "bob", (i.e.
 a Xen domU which has the same name as the login account of the user
 who is allowed to control it.), this has the downside that a local
 user may only control a single instance.

  The second solution is to add a line such as the following to the
 relevant instance configuration file beneath /etc/xen:

=for example begin

  xen_shell = 'bob, steve, chris'

=for example end

  This line, which will be ignored by Xen itself, will allow the Xen
 shell to be used by the three local users "bob", "steve", and "chris" -
 and each of them will be able to work with that host.

  If a user is allowed to control more than one instance upon the
 current host then the two commands "control" and "list" will be made
 available to them.


=cut



=head1 COMMAND BLACKLISTING

  There are times when you might want to setup this shell such that
 some commands are not available.

  For the optional commands this is straightfoward; simply do not
 configure anything they rely upon.

  For the built-in commands such as "version", "uptime", etc, you will
 need to use the built in blacklist support.

  There are two ways you can disable commands within the shell:

=over 8

=item Use /etc/cloud-shell/xen-shell.conf

=item Use a per-domain blacklist

=back


  To disable a command globally, amongst all instances upon a host,
 you can simply add the following to cloud-shell.conf:

=for example begin

  #
  #  Do not allow the following two commands
  #
  blacklist = version, uptime

=for example end

  If you wish to disable a command for just a single instance, or
 only a few machines, then edit the Xen configuration file(s) to include
 this:

=for example begin

  xen_shell_blacklist = 'version, uptime'

=for example end

=cut


=head1 REIMAGING SUPPORT

  The shell has a built-in "reimage" command which can be used by users
 to reinitialize their system.

  The reimage command itself does nothing, it merely executes an
  administrator-defined reimaging script.
  
  cloud-shell ships with an example script, xm-reimage, which expects a
  script "image.sh" existing in the user's home directory, it is assumed
  that you will write your own script - perhaps to invoke "xen-create-image"
  to do the real job.

  A sample script, ~skx/image.sh, might look like this:

=for example begin

   #!/bin/sh
   #
   # Reimaging script for the user skx.
   #

   # the instance to be reimaged will be passed upon the command line.
   host=$1

   # The username we are.
   user=$2

   # find the IP by grepping /etc/hosts.
   ip=$(grep "$host" /etc/hosts|awk '{print $1}')

   if [ ! -z "${ip}" ]; then

      xen-create-image --hostname=$host --ip=$ip \
      --size=9.5Gb --swap=512Mb --memory=256Mb --force \
      --dist=etch --admin=$user
   else

      echo "IP address not found for instance $host - aborting"

   fi

=for example end

=cut


=head1 REVERSE DNS SUPPORT

  This shell contains a built-in system for allowing a Xen-shell user to
 manipulate reverse DNS entries for IP addresses.  The shell itself doesn't
 do this directly, instead the shell will manipulate a simple text file
 in a users home directory.

  Create the file $HOME/ips.txt with contents of the following form:

=for example begin

   192.168.1.1 foo.my.flat
   192.168.1.2 bar.my.flat
   192.168.1.3 baz.my.flat

=for example end

  If this file is present then the "rdns" command will be available to
 that user.  The "rdns" command, when executed with no arguments will
 simply display this file.

  When the user attempts to set reverse DNS this file will be updated.

  It is assumed you will have your own cronjob to actually read these
 files and perform the DNS updates, the shell support is just half the
 implementation.

  If the file doesn't exist, or isn't writable, then the command will
 be disabled.

=cut


=head1 BANDWIDTH TRACKING

  If you've got the 'vnstat' tool installed upon your host and the
 primary network interface of your instance is given the same name
 as that of the instance you may see the bandwidth used via the 'bandwidth'
 command.

  To change the name of your interface you can configure your
 instance with something like this in the configuration file:

=for example begin

  vif = [ 'ip=192.168.1.100,vifname=skx' ]

=for example end

  Now when you run "ifconfig -a" upon the dom0 you'll see the instance
 has an interface named 'skx'.

  If the system cannot find a database for bandwidth tracking of
 a particular instance then the bandwidth command will be disabled.

=cut


=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

 Eric
 --
 http://www.grokthis.net/

=cut


=head1 LICENSE

xen-shell Copyright (c) 2005-2007 by Steve Kemp.  All rights reserved.
cloud-shell (c) 2006-2010 by Eric Windisch. All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut



#use strict;
use warnings;
use English;
use Getopt::Long;
use Pod::Usage;

use Crypt::PasswdMD5 qw(unix_md5_crypt);

BEGIN {
	push @INC,'/opt/cloud/lib/';
}
use Annelidous::Connector::Xen;
use Annelidous::Search;
use Annelidous::Frontend::XenShell::ActiveHandler;

package CloudShell;

#
#  Release number of this script.
#
my $RELEASE = '1.9.1';


#
#  Holder for values read from the configuration file, and the
# default values.
#
my %CONFIG;
$CONFIG{ 'pattern' }   = '/etc/xen/*';
$CONFIG{ 'config' }    = '/etc/xen-shell/xen-shell.conf';
$CONFIG{ 'blacklist' } = '';
$CONFIG{ 'reimage_cmd'} = '/usr/bin/xm-reimage';
$CONFIG{ 'allow_force_shutdown' } = 0;

#
#  Storage for the Xen configuration file(s) we've read.
#
#  We need to keep some pieces of data around to handle the case
# of users switching control to a difference instance, and being
# able to correctly determine which commands are allowed.
#
# (i.e coping with per-instance command blacklisting.)
#
my %xenBlacklists;


#
#  Dispatch table which contains the mapping between the commands
# we make available and the routine which implements that behaviour.
#
#  This table also contains both the long and the short form of each
# commands help text.
#
#
my %dispatch = (
    "archive" => {
        sub => \&do_archive,
        help =>
          "Perform an archive of the instance's block device(s)",
        info => "Archive instance",
    },
    "bandwidth" => { sub  => \&do_bandwidth,
                     #args => "[hourly|daily|weekly|monthly]",
                     help => "Show your bandwidth usage.",
                     info => "Show your bandwidth usage.",
                   },
    "boot" => {
        sub => \&do_boot,
        help =>
          "Start the instance, if it is not running.\nIf the 'console' parameter is used then show the console immediately..",
        args => "[console]",
        info => "Boot the instance.",
    },
    "control" => {
        sub => \&do_control,
        help =>
          "Take control of a particular instance.\nThis command makes all subsequent operations apply to the Xen instance specified.",
        info => "Specify which instance to control.",
    },
    "console" => {
        sub => \&do_console,
        help =>
          "Connect to the serial console of the Xen instance using GNU Screen.\n\nTo exit the serial prompt type 'Ctrl+]'\nYou may instead exit screen with 'Ctrl+a k', or 'Ctrl+a d'.",
        info => "Gain access to a instance via the serial console.",
    },
    "exit" => { sub  => \&do_exit,
                help => "Exit the shell.",
                info => "Exit the shell.",
              },
    "?" => {
        sub  => \&do_help,
        args => "[command]",
        help =>
          "Show help about the specified command, or all commands if no command is specified.",
        info => "Show general, or command-specific, help information.",
    },
    "help" => {
        sub  => \&do_help,
        args => "[command]",
        help =>
          "Show help about the specified command, or all commands if no command is specified.",
        info => "Show general, or command-specific, help information.",
    },
    "list" => {
        sub => \&do_list,
        help =>
          "Show the names of the Xen instances you may control upon this host.",
        info => "List Xen instances which you may control.",
    },
    "passwd" => { sub  => \&do_password,
                  help => "Change your login password.",
                  info => "Change the password used to access this host.",
                },
    "pause" => { sub  => \&do_pause,
                 help => "Pause your instance.",
                 info => "This will pause the instance.",
               },
    "quit" =>    # Dupe: exit
      { sub  => \&do_exit,
        help => "Exit this shell.",
        info => "Exit this shell.",
      },
    "reboot" => { sub  => \&do_reboot,
                  help => "Reboot the instance.",
                  info => "Reboot the instance.",
                },
    "rdns" => {
        sub  => \&do_rdns,
        args => "[ipaddress some.host.name]",
        help =>
          "Setup Reverse DNS for allocated IP addresses.\n\nWhen called with no arguments show current reverse DNS details.",
        info => "Setup reverse DNS for allocated IP addresses",
    },
    "reimage" => {
        sub => \&do_reimage,
        help =>
          "Erase a instance and reinitialise it to a fresh installation.",
        info => "Reset your system to a pristine installation.",
    },
    "restore" => {
        sub => \&do_restore,
        help =>
          "Recover from a backup.",
        info => "Restore files to your system.",
    },
    "serial" =>    # Dupe: console
      { sub => \&do_console,
        help =>
          "Connect to the serial console of the Xen instance using GNU Screen.\n\nTo exit the serial prompt type 'Ctrl+]'\nYou may instead exit screen with 'Ctrl+a k', or 'Ctrl+a d'.",
        info => "Gain access to the instance via the serial console.",
      },
    "shutdown" => {
        sub  => \&do_shutdown,
        args => "[force]",
        help =>
          "Shutdown the instance." . ($CONFIG{'allow_force_shutdown'}) ? "\nIf the 'force' parameter is used then we'll forcibly terminate." : "",
        info => "Shutdown the instance.",
    },
    "sshkey" => {
        sub  => \&do_sshkey,
        args => "[ssh-key]",
        help =>
          "Submit a new SSH key to the server for public-key authentication.  Takes the OpenSSH-format key as an argument.",
        info => "Configure SSH authentication.",
    },
    "status" => { sub  => \&do_status,
                  help => "Show whether the instance is running or not.",
                  info => "Show the status of the instance.",
                },
    "author" => { sub => \&do_author, },
    "sysreq" => {
        sub  => \&do_sysreq,
        args => "[string]",
        help =>
          "Send a 'sysreq' keystroke to the instance.\nThis allows you to try to cleanly shutdown a hung instance, for example.",
        info => "Send a 'sysreq' keystroke to the instance.",
    },
    "top" => {
            sub  => \&do_top,
            help => "Show the list of running instances, their CPU usage, etc.",
            info => "Show system resource usage.",
    },
    "unpause" => { sub  => \&do_unpause,
                   help => "Unpause your instance, and start it running again.",
                   info => "This will unpause the instance.",
                 },
    "uptime" => {
            sub  => \&do_uptime,
            help => "Show the uptime of the host & instance systems.",
            info =>
              "Show the uptime information of your instance system and this host.",
    },
    "version" => { sub  => \&do_version,
                   help => "Show the version of this shell, and of Xen.",
                   info => "Show the version of this shell, and of Xen.",
                 },
    "whoami" => {
                sub  => \&do_whoami,
                help => "Show the user you're connected as.",
                info => "Show the user you're connected to the host system as.",
    },
    "fetchuri" => {
                sub  => \&do_fetch,
                help =>
					"Fetch information from a URI / URL. For scripted use only.\n".
					"Returns -2 if no Content-Length provided by server.\n".
					"Returns -1 if Content-Length is greater than server limit.\n",
                info => "Fetch information from a URI / URL. FOR SCRIPTED USE ONLY.",
    },
	"setpref" => {
				sub => \&do_setpref,
				help => "Set configuration variables\n".
					"cpu_arch\t32 or 64-bit operation (64)\n".
					"autoheal\tautomatically restore system on powerloss (true)\n".
					"boot_method\tmethod to boot your instance (pv)\n".
					"disk_namespace\tdisk naming method (scsi)\n"
				,
				info => "Set configuration variables."
	},
	"getpref" => {
				sub => \&do_getpref,
				help => "Get configuration variables",
				info => "Get configuration variables."
	}
);

#
#  Parse any command line arguments which might be present.
#
#  Do this first so that --help, etc, works.
#
parseCommandLineArguments();



#
#  Parse our configuration file, if it exists.
#
parseConfigurationFile( $CONFIG{ 'config' } ) if ( -e $CONFIG{ 'config' } );

#
#  The previous lookup table contains *all* command mappings.
#
#  This hash contains a copy of that one, however this table will
# potentially have items removed.  Either:
#
#  1.  Because the command has been blacklisted.  (Globally, or per-instance).
#
#  2.  Because a supporting piece of software is not present. (eg. vnstat.)
#
my %lookupTable;

#
# Annelidous Search
#
use Data::Dumper;
use DBI;
require GrokThis::Cloud::Search;
my $anneSearch=GrokThis::Cloud::Search->new(
	-dbh=>DBI->connect(
		"DBI:".$CONFIG{'annelidous-search-dbdriver'}.":".
		"host=".$CONFIG{'annelidous-search-dbhost'}.";".
		"database=".$CONFIG{'annelidous-search-dbname'}.";",
		$CONFIG{'annelidous-search-dbuser'},
		$CONFIG{'annelidous-search-dbpass'})
);


#
# Annelidous
#
require Annelidous::Frontend;
require Annelidous::Connector::Xen;
require GrokThis::Cloud::Storage;
my $annelidous=new Annelidous::Frontend(
	-search_module=>$anneSearch,
	-connector_module=>Annelidous::Connector::Xen,
	-storage_module=>GrokThis::Cloud::Storage
);

#
# The instances that the current user may control.
#
my @INSTANCES;

#
#  The name of the instance currently being controlled.
#
my $ACTIVE = '';

#
# Tie ACTIVE to ActiveHandler.
# ActiveHandler will update the $vm object.
#
tie $ACTIVE, "Annelidous::Frontend::XenShell::ActiveHandler", $annelidous;

# Execute main subroutine, unless we're being subclassed...
__PACKAGE__->main() unless caller;

=begin doc

  Parse any command line options which might be present.

=end doc

=cut

sub parseCommandLineArguments
{
    my $SHOW_HELP    = 0;
    my $SHOW_MANUAL  = 0;
    my $SHOW_VERSION = 0;

    #
    #  Parse options.
    #
    if (
        !Getopt::Long::GetOptions(
            "help",    \$SHOW_HELP,
            "manual",  \$SHOW_MANUAL,
            "version", \$SHOW_VERSION,

            "control=s", \$CONFIG{ 'control' },
                   ) )
    {
        exit;
    }

    pod2usage(1) if $SHOW_HELP;
    pod2usage( -verbose => 2 ) if $SHOW_MANUAL;

    if ($SHOW_VERSION)
    {
        if ( $CONFIG{ 'banner' } )
        {
            print $CONFIG{ 'banner' } . "\n";
        }
        else
        {
            print "cloud-shell v$RELEASE\n";
        }
        exit;
    }
}



=begin doc

  Parse our configuration file.

=end doc

=cut

sub parseConfigurationFile
{
    my ($file) = (@_);

    #
    #  Make sure the file is specified + exists.
    #
    return if ( !-e $file );

    open( FILE, "<", $file ) or die "Cannot read file '$file' - $!";
    while ( defined( my $line = <FILE> ) )
    {
        chomp $line;

        # Skip lines beginning with comments
        next if ( $line =~ /^([ \t]*)\#/ );

        # Skip blank lines
        next if ( length($line) < 1 );

        # Strip trailing comments.
        if ( $line =~ /(.*)\#(.*)/ )
        {
            $line = $1;
        }

        # Find variable settings
        if ( $line =~ /([^=]+)=([^\n]+)/ )
        {
            my $key = $1;
            my $val = $2;

            # Strip leading and trailing whitespace.
            $key =~ s/^\s+//;
            $key =~ s/\s+$//;
            $val =~ s/^\s+//;
            $val =~ s/\s+$//;

            # Store value.
            $CONFIG{ $key } = $val;
        }
    }

    close(FILE);
}



=begin doc

  Sanity check that we can load the Perl modules we require.

  Also make sure the current user has a instance on this host machine.

  Note that if we detect errors we will sleep for a while after displaying
 them - this is to allow users of PuTTY to see them before they are logged
 out.  (Because PuTTY closes the window on disconnection by default.)

=end doc

=cut

sub sanityCheck
{

    #
    #  Test we have the perl modules we need.
    #
    BEGIN
    {
        eval {
            require Term::ReadLine;
            require Term::ReadLine::Gnu;
        };
    }
#    if ($@)
#    {
#        print "Package 'Term::ReadLine::Gnu' not installed.\n";
#        print "Aborting\n";
#        sleep 5;
#        exit;
#    }

    #
    #  Test that the current user has a sane name only letters digits
    # and the underscore are allowed
    #
    if ( $USER !~ /^([a-zA-Z0-9_-]+)$/ )
    {
        print "Username '$USER' contains disallowed characters.\n";
        print "Aborting\n";
        sleep 5;
        exit;
    }

    #
    #  Test that the user has a instance present upon this host.
    #
    #  We parse each file beneath the Xen configuration directory and
    # look for suitable instances.
    #
    #
    #@INSTANCES = findInstancesFor($USER);
	my @DBINSTANCES = $annelidous->search->find_active_byusername($USER);
	foreach my $inst (@DBINSTANCES) {
		#push @INSTANCES, $inst->{username};
		push @INSTANCES, $inst->{id};
	}
    #@INSTANCES = $annelidous->search->find_byusername($USER);
    if ( !@INSTANCES || scalar(@INSTANCES) < 1 )
    {
        print "User '$USER' doesn't have a instance on this host.\n";
        print "Aborting\n";
        sleep 5;
        exit;
    }

    #
    #  If the user only has one instance under their control we'll
    # default to controlling that one.
    #
    #if ( scalar(@INSTANCES) == 1 )
    #{
        $ACTIVE = $DBINSTANCES[0]->{'id'}; 
    #}

}


=begin doc

  Can the current user control the specified instance?

=end doc

=cut

sub canControl
{
    my ($inst) = (@_);

    #
    #  Seach for the results
    #
    return ( grep /^\Q$inst\E$/i, @INSTANCES );
}



=begin doc

  Ensure that the user has a current host specified to control,
 and that they can control that instance.

  This is used by all commands which require an instance to operate
 upon.

  Return 0 on error, 1 if there is an appropriate instance controlled.

=end doc

=cut

sub isControlling
{

    #
    #  Make sure we have an active machine.
    #
    if ( !length($ACTIVE) )
    {
        print <<EOF;

  You have not selected a Xen instance to control, and this command
 is an instance-specific one.

  You may use the following two commands:

    list    ->  Show which Xen instances you may control.

    control ->  Take control of the specified Xen instance.

EOF
        return 0;
    }

    #
    #  Sanity check - ensure the user can control the
    # selected instance.  This should never fail.
    #
    return 0 if ( !canControl($ACTIVE) );

    #
    #  The user is OK to operate the relevant command
    #
    return 1;
}



=begin doc

  Remove any commands which the current user cannot use.

  This means:

    - We remove "vnstat" if there is no bandwidth accounting.
    - We remove "rdns" if ~/ips.txt is missing or non-writable.
    - We remove "passwd" if ~/.ssh/authorized_keys is present and non-empty.
    - We remove "list" + "control" if the user can only access one instance.
    - We remove any command blacklisted in /etc/cloud-shell/xen-shell.conf

=end doc

=cut

sub removeCommands
{

    #
    #  Bandwidth:  Remove this command unless there is at least one
    # instance which is setup correctly.
    #
    my $has_vnstat = 0;
    #foreach my $name (@INSTANCES)
    #{
    #    $has_vnstat = 1 if ( -e "/var/lib/vnstat/$name" );
	#}
	$has_vnstat = 1 if ( -e "/var/lib/vnstat/$USER" );

    if ( !$has_vnstat )
    {
        $dispatch{ 'bandwidth' } = undef;
        delete( $dispatch{ 'bandwidth' } );
    }

    #
    #  rdns
    #
    if ( ( !-e $HOME."/ips.txt" ) ||
         ( !-w $HOME."/ips.txt" ) )
    {
        $dispatch{ 'rdns' } = undef;
        delete( $dispatch{ 'rdns' } );
    }

# EricW: removing this for now... this isn't exclusionary.
    #
    #  Password changing isn't available if key-based auth is used.
    #
#    if ( -s $HOME."/.ssh/authorized_keys" )
#    {
#        $dispatch{ 'passwd' } = undef;
#        delete( $dispatch{ 'passwd' } );
#    }

    #
    #  If the user can only control one instance then there is
    # no need for "control" and "list".
    #
    if ( scalar(@INSTANCES) < 2 )
    {
        $dispatch{ 'control' } = undef;
        delete( $dispatch{ 'control' } );

        $dispatch{ 'list' } = undef;
        delete( $dispatch{ 'list' } );
    }

    #
    #  Remove globally blacklisted commands
    #
    foreach my $banned ( split( /,/, $CONFIG{ 'blacklist' } ) )
    {

        # strip leading and trailing whitespace
        $banned =~ s/^\s+//;
        $banned =~ s/\s+$//;

        next if ( !length($banned) );

        # lowercase, because all our commands are.
        $banned = lc($banned);
        $dispatch{ $banned } = undef;
        delete( $dispatch{ $banned } );
    }

    #
    #  Now we've removed globally unavailable commands update
    # the copy we'll work from.
    #
    %lookupTable = %dispatch;
}



=begin doc

 Show the startup banner for the shell.

=end doc

=cut

sub showBanner
{
    if ( $CONFIG{ 'banner' } )
    {
        print $CONFIG{ 'banner' } . "\n";
    }
    else
    {
        print "cloud-shell v$RELEASE - type 'help' for help.\n";
    }
}



=begin doc

  Create the terminal interface, complete with command completion.

  Rather than hard-wiring the commands which are available we take them
 from our global dispatch table.

=end doc

=cut

sub createTerminal
{
    my $term = new Term::ReadLine 'cloud-shell';

    #
    # Process our dispatch table to determine which commands
    # are available.
    #
    my @cmds = ();

    #
    #  Add all commands.
    #
    push @cmds, ( keys %dispatch );

    #
    #  Add all Xen instances the user can control if there are more than one.
    #
    if ( scalar(@INSTANCES) > 1 )
    {
        push @cmds, (@INSTANCES);
    }

    #
    #  Remove the easter function.
    #
    @cmds = grep( !/^author$/, @cmds );

    #
    #  Add completion
    #
    my $attribs = $term->Attribs;
    $attribs->{ completion_entry_function } =
      $attribs->{ list_completion_function };
    $attribs->{ completion_word } = \@cmds;

    #
    #  Return it
    #
    return ($term);
}



=begin doc

  If the user has a history present in ~/.cloud-shell load it up.

=end doc

=cut

sub loadHistory
{
    my ($term) = (@_);

    #
    #  The name of the history file.
    #
    my $hist = $CONFIG{ 'history' } || ".cloud-shell";

    #
    #  Load the file, if it exists, from the home directory.
    #
    my $file = $ENV{ 'HOME' } . "/" . $hist;
    if ( -e $file )
    {

        #
        #  Load the history if we can.
        #
        if ( UNIVERSAL::can( $term, 'ReadHistory' ) )
        {
            $term->ReadHistory($file);
        }
    }
}

sub shell_javascript {
	my $term = shift;

	# Eddy-fire-lizard!
	use JavaScript::SpiderMonkey;

    #
    #  Prompt
    #
    my $prompt = getPrompt();

	# We create a *safe* TCL interpreter
	# Stdout is allowed...
	my $js = JavaScript::SpiderMonkey->new();
	$js->init();

	# Provide functional write functions.
    $js->function_set("write", sub { print "@_"; });
    $js->function_set("writeln", sub { print "@_\n"; });
	$document = $js->object_by_path("document");
    $js->function_set("write", sub { print "@_"; }, $document);
    $js->function_set("writeln", sub { print "@_\n"; }, $document);

	foreach (keys %lookupTable) {
		$js->function_set($_,$lookupTable{$_}->{'sub'});
	}
	$js->function_set("_uriexec",sub {
		$js->eval(do_fetch(@_));
	});

    #
    #  Command loop.
    #
    while ( defined( my $line = $term->readline($prompt) ) )
    {

        # Ignore empty lines.
        next if ( !length($line) );

        # Strip leading and trailing whitespace.
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;

		if ($js->eval($line) == 1) {
			$term->add_history($line);
		} else {
			$@ =~ s/\s*at \/usr.*//;
			print $@;
			print "Type 'help' for help.\n";
		}

        #
        #  Update the prompt - required in the case where the user
        # has switched control to another instance.
        #
        $prompt = getPrompt();
    }
}

sub shell_ruby {
	my $term = shift;

	# Gem-ity-cricket! 
	use Inline::Ruby;

    #
    #  Prompt
    #
    my $prompt = getPrompt();

	# Hack to bring our perl functions into Ruby
Inline::Ruby::rb_eval <<RUBY;
\$perlfunc={}
def register_perl (funname,funref)
	\$perlfunc[funname] = funref
end
RUBY

	# We can't declare a '?' method here.
	delete $lookupTable{'?'};
	foreach my $cmd (keys %lookupTable) {
		Inline::Ruby::rb_call_function(
			'register_perl',$cmd,sub { $lookupTable{$cmd}->{'sub'}(@_) }
		);
		Inline::Ruby::rb_eval(qq{
def $cmd (*args)
	return \$perlfunc['$cmd'].call(*args)
end
		});
	}

	# We create a *safe* Ruby interpreter
	# this must be done after the evil hacks above...
	Inline::Ruby::rb_eval('$SAFE=4');

    #
    #  Command loop.
    #
    while ( defined( my $line = $term->readline($prompt) ) )
    {

        # Ignore empty lines.
        next if ( !length($line) );

        # Strip leading and trailing whitespace.
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;

		eval {
			Inline::Ruby::rb_eval($line);
			$term->add_history($line);
		};
		if ($@) {
			$@ =~ s/\s*at \/usr.*//;
			print $@;
			print "Type 'help' for help.\n";
		}

        #
        #  Update the prompt - required in the case where the user
        # has switched control to another instance.
        #
        $prompt = getPrompt();
    }
}


#
# This doesn't work!
# Simple commands like help do, but
# not ones that use the API, get errors like:
# Can't locate package Annelidous::Connector for @Annelidous::Connector::Xen::ISA
#
sub shell_perl {
	my $term = shift;

	# We've gotta be safe!
	use Safe;

    #
    #  Prompt
    #
    my $prompt = getPrompt();

	# We create a *safe* Perl interpreter
	my $interp=new Safe("Dungeon");

	my %cmds;
	delete $lookupTable{'?'};
	foreach my $cmd (keys %lookupTable) {
		print "Adding $cmd.\n";
		eval qq{
			sub Dungeon::$cmd {
				\$lookupTable{'$cmd'}->{'sub'}();
			}
		};
		print $@."\n" if ($@);
	}

    #
    #  Command loop.
    #
    while ( defined( my $line = $term->readline($prompt) ) )
    {

        # Ignore empty lines.
        next if ( !length($line) );

        # Strip leading and trailing whitespace.
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;

		my $ret=$interp->reval($line);
		if (defined($ret)) {
			$term->add_history($line);
		} else {
			print "Unknown or bad command.\n";
			print "Type 'help' for help.\n";
		}

        #
        #  Update the prompt - required in the case where the user
        # has switched control to another instance.
        #
        $prompt = getPrompt();
    }
}


sub shell_tcl {
	my $term = shift;

	# We only include this evil beast if we're using it.
	use Tcl;

    #
    #  Prompt
    #
    my $prompt = getPrompt();

	# We create a *safe* TCL interpreter
	# Stdout is allowed...
	my $t=Tcl::new();
	my $tcl=$t->CreateSlave('slave',1);
	$t->Eval("interp share {} stdout slave");

	# Init shell
	open(my $TCLinit, "/etc/cloudinf/cloud-shell.init.tcl");
	$tcl->EvalFileHandle($TCLinit);
	close $TCLinit;

	foreach (keys %lookupTable) {
		$tcl->CreateCommand($_,sub {
			my $function=shift;
			my $interp=shift;
			my $function1=shift;
			$lookupTable{$function}->{'sub'} (@_);
		}, $_);
	}
	$tcl->CreateCommand("_uriexec",sub {
		my $function=shift;
		my $interp=shift;
		my $function1=shift;
		$interp->Eval(do_fetch(@_));
	},$_);
    #
    #  Command loop.
    #
    while ( defined( my $line = $term->readline($prompt) ) )
    {

        # Ignore empty lines.
        next if ( !length($line) );

        # Strip leading and trailing whitespace.
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;

		eval {
		$tcl->Eval($line);
		$term->add_history($line);
		};
		if ($@) {
			$@ =~ s/\s*at \/usr.*//;
			print $@;
			print "Type 'help' for help.\n";
		}

        #
        #  Update the prompt - required in the case where the user
        # has switched control to another instance.
        #
        $prompt = getPrompt();
    }
}


=begin doc

  Run the input reading + dispatching loop.   We use the dispatch
 table already defined to handle input.

  Parsing of command line input is extremely minimal - we break the
 input line into "word" which is the first whitespace deliminated
 token on the line and "args" which is the remainder of the line.

  This is sufficient for our purposes.

=end doc

=cut

use Switch;

sub runMainLoop
{
    my ($term) = (@_);
	# Determine which interactive shell to use.
	my $shell=(tied $ACTIVE)->vm->data->{interactive_shell};
	$shell ||= "tcl";

	switch ($shell) {
		case "tcl" { &shell_tcl ($term); }
		case "javascript" { &shell_javascript ($term); }
		case "ruby" { &shell_ruby ($term); }
		#case "perl" { &shell_perl ($term); }
		else { &shell_tcl ($term); }
		#/javascript/ && &shell_javascript $term;
		#/simple/ && &shell_simple $term;
	}
    #
    #  Save history on exit.
    #
    do_exit();
}



=begin doc

  Return a suitable prompt for use by the shell.

  The prompt varies depending on what kind of control the user has,
 and which instance is being controlled.

=end doc

=cut

sub getPrompt
{

    #
    #  If there is only one instance then "cloud-shell>".
    #
    return "cloud-shell> " if ( scalar(@INSTANCES) == 1 );

    #
    #  If there is an active instance then include that in the prompt.
    #
    return "cloud-shell[$ACTIVE]> " if ( length($ACTIVE) );

    #
    #  Otherwise the default.
    #
    return "cloud-shell> ";
}



=begin doc

  Helper method to see if an instance is running.

=end doc

=cut

sub isRunning
{
    #my ($name) = (@_);
    #return (tied $name)->connector->status;
    my $status=(tied $ACTIVE)->connector->status;
	print "$status\n";
	return $status;
}



##
#  Now we have the various handlers.
#
#  Handlers are listed alphabetically with each handler having a function
# named "do_" + command-name.
#
##




=begin doc

  Show the author.

=end doc

=cut

sub do_author
{
    print "Eric Windisch <eric\@grokthis.net>\n";
    print "Forked from xen-shell by Steve Kemp <steve\@steve.org.uk>\n";
}



=begin doc

  Show your bandwidth usage.

=end doc

=cut

sub do_bandwidth
{
		(tied $ACTIVE)->connector->bw();
}



=begin doc

  Boot the instance instance.

=end doc

=cut

sub do_boot
{
    my ($arg) = (@_);

    #
    #  Is this to be a forced shutdown?
    #
    my $console = 0;
    $console = 1 if ( defined($arg) && ( lc($arg) eq "console" ) );

    #
    #  Make sure the user has selected an instance
    # they can control.
    #
    return if ( !isControlling() );

    print "Booting instance: $ACTIVE\n";

# TODO: Implement console
    if ($console)
    {
		#(tied $ACTIVE)->connector->boot(-console=>{ -tty=>$local_tty });
		(tied $ACTIVE)->connector->boot();
		&do_console;
    }
    else
    {
		#print "connector:";
		#print Dumper scalar((tied $ACTIVE)->connector);
		(tied $ACTIVE)->connector->boot();
        print "Use 'console' to see the bootup messages.\n";
    }
}

=begin doc

  Connect to the serial console of the running instance.

=end doc

=cut

sub do_console
{

    #
    #  Make sure the user has selected an instance
    # they can control.
    #
    return if ( !isControlling() );

    print "\nRunning console for $ACTIVE - exit with Ctrl+]\n";
    print
      "(You might need to press return a couple of times to see activity.)\n\n";

	(tied $ACTIVE)->connector->console();

    print "\n";
}



=begin doc

  Mark a particular instance as being current.

=end doc

=cut

sub do_control
{
    my ($inst) = (@_);

    #
    #  Make sure we got an instance.
    #
    if ( !defined($inst) || !length($inst) )
    {
        print "Usage: control instanceName\n";
        return;
    }


    #
    #  If the user can control that instance then switch to it.
    #
    if ( canControl($inst) )
    {
        print "Controlling: $inst\n";
        $ACTIVE      = $inst;
        %lookupTable = %dispatch;

        #
        #  Now remove any blacklisted commands, if we have any.
        #
        if ( $xenBlacklists{ $inst } )
        {
            foreach my $banned ( split( /,/, $xenBlacklists{ $inst } ) )
            {

                # strip leading and trailing whitespace
                $banned =~ s/^\s+//;
                $banned =~ s/\s+$//;

                next if ( !length($banned) );

                # lowercase, because all our commands are.
                $banned = lc($banned);

                $lookupTable{ $banned } = undef;
                delete( $lookupTable{ $banned } );
            }
        }
    }
    else
    {
        print
          "The instance was not found, or you are not allowed to control it.\n";
    }
}



=begin doc

 Exit this shell, first saving any command history.

=end doc

=cut

sub do_exit
{

    #
    #  The name of the history file, inside the home directory.
    #
    my $hist = $CONFIG{ 'history' } || ".cloud-shell";
    my $file = $ENV{ 'HOME' } . "/" . $hist;

    #
    #  Save the history if the term module can.
    #
    if ( UNIVERSAL::can( $term, 'WriteHistory' ) )
    {
        $term->WriteHistory($file);
    }

    exit;
}



=begin doc

  Show the user some help.

  When called with no arguments it will display all supported commands.

  If called with arguments then they we will show only help for the
 specified command(s).

=end doc

=cut

sub do_help
{
    my ($term) = (@_);

    #
    #  Help on a single command
    #
    if ( ( defined($term) ) && ( length($term) ) )
    {
        foreach my $cmd ( split( /[ \t]/, $term ) )
        {

            # Lookup command in our dispatch table.
            my $c = $dispatch{ lc($cmd) };
            if ($c)
            {
                my $args = $c->{ 'args' };

                if ( !defined($args) ) {$args = '';}

                print "\nCommand: $cmd $args\n\n";
                print $c->{ 'help' } . "\n";
            }
            else
            {
                print "Unknown command '$cmd' - no help text available\n";
            }
        }
        return;
    }


    #
    #  Header
    #
    if ( $CONFIG{ 'banner' } )
    {
        print $CONFIG{ 'banner' } . "\n";
    }
    else
    {
        print "cloud-shell v$RELEASE\n";
    }
    print "The following commands are available within this shell:\n\n";

    #
    #  Build up the short-help, indented it nicely.
    #
    foreach my $entry ( sort keys %dispatch )
    {
		# Skip entries starting with -, these are hidden,
		# undocumented features (generally still in testing)
		next if ($entry =~ /^-/);

        my $hash = $dispatch{ $entry };

        print sprintf( "%10s - %s\n", $entry, $hash->{ 'info' } );
    }

    #
    #  Footer.
    #
    print "\nFor command-specific help run \"help command\".\n\n";

}



=begin doc

  Show the user the names of the Xen instances they may control.

=end doc

=cut

sub do_list
{
    print "You may control the following Xen instances:\n\n";

    map( { print "\t$_\n" } @INSTANCES );

    print "\n(Use 'control' to take control of a particular instance.)\n";
}



=begin doc

  Allow the user to change their login password, if password-based
 authentication is in use.

  Note this function is disabled if ~/.ssh/authorized_keys is present.

=end doc

=cut

# uses global @salt to construct salt string of requested length
sub gensalt {
	my $count = shift;
	my @saltA = @_;

	my $salt;
	for (1..$count) {
	$salt .= (@saltA)[rand @saltA];
	}

	return $salt;
}

sub do_password
{
	my ($args,$args2) = split(/ /, shift);
	#my ($args,$args2) = (@_);
	#print "$args $args2";
	my $encrypted;
	my @salt = ( '.', '/', 0 .. 9, 'A' .. 'Z', 'a' .. 'z' );

	unless ( defined ($args) && defined ($args2) ) {
	#if ( length($args) < 1 || length($args2) < 1 ) {
		print "Command usage:\n password NEW_PASSWORD REPEAT_PASSWORD\n";
		return;
	}
	if (length($args) < 6) {
		print "Password too short.\n";
		return;
	}
	unless ($args eq $args2) {
		print "Passwords do not match.\n";
		return;
	}


	$encrypted=unix_md5_crypt( $args, gensalt(8,@salt) );

    #system("passwd");
	my $dbh=$anneSearch->{dbh};
	my $sth=$dbh->prepare("update PACKAGES set password=? where username=?");
	$sth->execute($encrypted,$USER);
	$sth->finish();
	print "Password changed.\n";
}



=begin doc

  This will pause the instance.

=end doc

=cut

sub do_pause
{

    #
    #  Make sure the user has selected an instance
    # they can control.
    #
    return if ( !isControlling() );

    print "Pausing instance: $ACTIVE\n";
    (tied $ACTIVE)->connector->pause;

}



=begin doc

  Reboot the instance.

=end doc

=cut

sub do_reboot
{

    #
    #  Make sure the user has selected an instance
    # they can control.
    #
    return if ( !isControlling() );

    print "Rebooting instance: $ACTIVE\n";

    #system("sudo xm reboot $ACTIVE");
    (tied $ACTIVE)->connector->reboot;
}

=begin doc

  Allow the machine to be restored from a backup.

=end doc

=cut

sub do_restore
{
    #
    #  Make sure the user has selected an instance
    # they can control.
    #
    return if ( !isControlling() );

    print "Restoring instance: $ACTIVE\n";

    #
    # See if the instance is running
    #
    if ( isRunning($ACTIVE) )
    {
        print "Instance running.\n";
        print "Please run 'shutdown' first\n";
        return;
    }
    else
    {
        print "Machine not running, proceeding\n";
    }


    #
    #  Run the xm-reimage
    #
	(tied $ACTIVE)->connector->restore();
	print "Your instance has been restored to its prior state.\n";
}

=begin doc

 Backup the image.

=end doc

=cut

sub do_archive
{
    #
    #  Make sure the user has selected an instance
    # they can control.
    #
    return if ( !isControlling() );

    #
    # See if the instance is running
    #
    if ( isRunning($ACTIVE) )
    {
        print "Instance running. Proceeding.\n";
	} else {
        print "Instance not running, please 'boot' first\n";
        return;
    }

    print "Archiving instance: $ACTIVE\n\n";
	print "NOTE: Your instance has been paused and will resume when the archive is complete.\n";
	print "\tThis archive should take approximately 05-60 minutes.\n\n";

    #
    #  Run the xm-reimage
    #
	(tied $ACTIVE)->connector->archive();
	print "Your instance has been resumed.\n";
}


=begin doc

  Allow the machine to be reinitialised to a fresh installation of
 their instance.

=end doc

=cut

sub do_reimage
{
    #
    #  Make sure the user has selected an instance
    # they can control.
    #
    return if ( !isControlling() );

    print "Reimaging instance: $ACTIVE\n";

    #
    # See if the instance is running
    #
    if ( isRunning($ACTIVE) )
    {
        print "instance running.\n";
        print "Please run 'shutdown' first\n";
        return;
    }
    else
    {
        print "Machine not running, proceeding\n";
    }


    #
    #  Run the xm-reimage
    #
	(tied $ACTIVE)->connector->reimage();
	print "You may now boot your instance\n";
}

=begin doc

  Submit public key to the server for key-based SSH authentication.

=end doc

=cut

sub do_sshkey
{
    my ($args) = (@_);

    if ( !defined($args) || ( !length($args) ) )
    {
		unless (-f $HOME."/.ssh/authorized_keys") {
			print "No SSH key defined. Set one with 'sshkey KEY'";
			return;
		}

		print "Displaying SSH key.\n\n";
		print "--- BEGIN SSH KEYS ---\n";
        # No arguments just show the current SSH key.
        open( CURRENT, "<", $HOME."/.ssh/authorized_keys" ) or return;
        while (<CURRENT>)
        {
            print;
        }
        close(CURRENT);
		print "--- END SSH KEYS ---:\n";
        return;
    }


    #
    #  We have an agument.  Assume it is of the form:
    #
    #  sshkey [format] [base64] [comment*]
    #  or practically: ssh-rsa ABCD skx@example.com
    #
    my ( $format, $base64, $comment ) = split( /[ \t]/, $args, 3 );

    #
    #  Test that the format is supported.
    #
    #  As of 12/08, all possible keys begin with the pattern
    #  /^ssh-(rsa|dss)/ yet the format specification may be longer, such as
    #  with the format "ssh-rsa-x509v3".  For this reason, we check
    #  both, according to all formats defined at the time of this writing:
    #
    #   ssh-dss        REQUIRED    sign  no-cert Simple DSS
    #   ssh-rsa        RECOMMENDED sign  no-cert Simple RSA
    #   ssh-dss-x509v3 RECOMMENDED sign  cert    X.509 certificates (DSS)
    #   ssh-rsa-x509v3 RECOMMENDED sign  cert    X.509 certificates (RSA)
    #   ssh-dss-spki   OPTIONAL    sign  cert    SPKI certificates (DSS)
    #   ssh-rsa-spki   OPTIONAL    sign  cert    SPKI certificates (RSA)
    #   ssh-dss-pgp    OPTIONAL    sign  cert    OpenPGP certificates (DSS)
    #   ssh-rsa-pgp    OPTIONAL    sign  cert    OpenPGP certificates (RSA)
    #
    if ( $format !~ /^ssh-(rsa|dss)/ )
    {
        print "The given key does not specify a supported key format.\n". \
		"Keys must be formatted for OpenSSH.";
        return;
    }
    if ( $format =~ /^ssh-(rsa|dss)-(.*)/ ) {
    	$_=$2;
	unless (/x509v3/ || /spki/ || /pgp/) {
	    print "The given key specifies an unknown format.\n";
	    return
	}
    }

    #
    # Here we will drop entries identical or similar.
    #
	print "Reading in $HOME/.ssh/authorized_keys\n";
	if (-f $HOME."/.ssh/authorized_keys") {
		my @lines;
		open( CURRENT, "<", $HOME."/.ssh/authorized_keys" ) or return;
		while (<CURRENT>)
		{
			my $line = $_;
			my ( undef, $b, undef ) = split( /[ \t]/, $line, 3 );

		# Do the drop.
			unless ( $b eq $base64 )
		{
			push @lines, $line;
		}
		}
		close(CURRENT);
	}

    # Add our new line to the file
    push @lines,sprintf("%s %s %s\n", $format, $base64, $comment);

	print "Setting SSH Key in $HOME/.ssh/authorized_keys\n";
    #
    #  Save the new details.
    #
    open( NEW, ">", $HOME."/.ssh/authorized_keys" );
    foreach my $l (@lines)
    {
	print NEW $l;
    }
    close(NEW);
    print "Updated the authorized_keys file for key $base64\n";
}



=begin doc

  Control reverse DNS for this user.

  This allows the user to view/modify the contents of ~/ips.txt

  Another script is required to actually take the contents of the files
 and perform the DNS updates.

=end doc

=cut

sub do_rdns
{
    my ($args) = (@_);

    if ( !defined($args) || ( !length($args) ) )
    {

        # No arguments just show the current IP setup.
        open( CURRENT, "<", $HOME."/ips.txt" ) or return;
        while (<CURRENT>)
        {
            print;
        }
        close(CURRENT);
        return;
    }


    #
    #  We have an agument.  Assume it is of the form:
    #
    #  rdns xx.xx.xx.xx some.host.name
    #
    my ( $ip, $host ) = split( /[ \t]/, $args );

    #
    #  Test that the arguments are the right way round!
    #
    if ( $ip !~ /^([0-9.]*)$/ )
    {
        print "The IP address you've specified isn't numerical: '$ip'\n";
        return;
    }

    #
    #  OK we have a host and IP, we want to open the users file
    # and update the hostname if it matches.
    #
    my $updated = 0;
    my @lines;

    open( CURRENT, "<", $HOME."/ips.txt" ) or return;
    while (<CURRENT>)
    {
        my $line = $_;
        my ( $i, $h ) = split( /[ \t]/, $line );
        if ( $i eq $ip )
        {
            $line    = $ip . " " . $host . "\n";
            $updated = 1;
        }

        push @lines, $line;
    }
    close(CURRENT);

    #
    #  If we updated save the new details.
    #
    if ($updated)
    {
        open( NEW, ">", $HOME."/ips.txt" );
        foreach my $l (@lines)
        {
            print NEW $l;
        }
        close(NEW);
        print "Set the reverse DNS for $ip to $host\n";

        #
        #  If we have a post-update command then we'll execute it.
        #
        if ( defined( $CONFIG{ 'updatedns' } ) &&
             length( $CONFIG{ 'updatedns' } ) )
        {

            #
            #  The command we'll run.
            #
            my $cmd = $CONFIG{ 'updatedns' };

            #
            #  Does this need a file to be inserted into the command line?
            #
            if ( $cmd =~ /\$FILE/ )
            {
                $cmd =~ s/\$FILE/$HOME\/ips.txt/g;
            }

            #
            #  Run the potentially modified command.
            #
            system($cmd );
        }
        else
        {

            #
            #  No command - we assume cron-fu will update the entries,
            # so we should tell the user to expect a wait.
            #
            print "Please wait an hour or two for it to take effect\n";

        }
    }
    else
    {
        print "IP details for IP '$ip' not found.  Ignoring\n";
    }
}



=begin doc

  Shutdown the instance.

=end doc

=cut

sub do_shutdown
{
    my ($arg) = (@_);

    #
    #  Is this to be a forced shutdown?
    #
    my $force = 0;
    if ( $CONFIG{'allow_force_shutdown'} == 1 ) {
	$force = 1 if ( defined($arg) && ( lc($arg) eq "force" ) );
    }

    #
    #  Make sure the user has selected an instance
    # they can control.
    #
    return if ( !isControlling() );

	unless ($force) {

    print "Shutting down instance: $ACTIVE\n";
    (tied $ACTIVE)->connector->shutdown;
	}
    #
    #  If we're forcing then we want to make sure it is gone.
    #
    if ($force)
    {
#        print "Waiting to see if the shutdown succeeded.\n";
#
#        my $running = isRunning($ACTIVE);
#        my $count   = 9;
#
#        #
#        #  Sleep for five seconds to see if it worked.
#        #
#        #  Repeat a few times.
#        #
#        print "Waiting: ";
#        while ( ($count) && ($running) )
#        {
#            $running = isRunning($ACTIVE);
#
#            print "$count.. ";
#            sleep(5);
#
#            $count -= 1;
#        }
#        print "\n";
#
#        #
#        #  If it is *still* running then force it.
#        #
#        if ($running)
#        {
#            print "Still running.  Forcing the shutdown.\n";
#
#            #
#            #  Send the sysreqs
#            #
#            do_sysreq("reissuo");
#
#            sleep(2);
			(tied $ACTIVE)->connector->destroy;

            print "System terminated.\n";
#        }
#        else
#        {
#
#            #
#            #  The shutdown busy-loop worked.
#            #
#            print "Instance terminated\n";
#        }
    }
}



=begin doc

  Show status of the instance:  Running/Shutdown

  If the instance is running then show its uptime too.

=end doc

=cut

sub do_status
{

    #
    #  Make sure the user has selected an instance
    # they can control.
    #
    return if ( !isControlling() );

    #
    #  Is the instance running?
    #
    my $running = isRunning($ACTIVE);


    #
    # Show state.
    #
    if ($running)
    {
        print "Guest : Running\n";
	}
    else
    {
        print "Guest: Shutdown\n";
    }
}



=begin doc

  Send a single sysreq keystroke to the current instance.

=end doc

=cut

sub do_sysreq
{
    my ($string) = (@_);

    #
    #  Make sure the user has selected an instance
    # they can control.
    #
    return if ( !isControlling() );

    #
    #  Make sure we recieved a key.
    #
    if ( !defined($string) )
    {
        print <<EOF;
Usage: sysreq [string]

  Each character of the string will be sent as a sysreq key.
EOF
        return;
    }

    #
    #  Split into letters.
    #
    foreach my $letter ( split( //, $string ) )
    {

        #
        #  a-z + ? are the only valid keys we care about.
        #
        if ( $letter =~ /[a-z\?]/ )
        {
            print "Sending sysreq: $letter\n";
			(tied $ACTIVE)->connector->sysrq($letter);
        }
    }
}



=begin doc

  Show Xen top information.

=end doc

=cut

sub do_top
{
    #system("sudo xm top");
	print "top not supported in this version.\n";
    #system("clear");
}



=begin doc

  This will unpause the instance.

=end doc

=cut

sub do_unpause
{

    #
    #  Make sure the user has selected an instance
    # they can control.
    #
    return if ( !isControlling() );

    print "Un-pausing instance: $ACTIVE\n";

	(tied $ACTIVE)->connector->unpause;
}



=begin doc

  Show uptime of the instance.

=end doc

=cut

sub do_uptime
{

    #
    #  Make sure the user has selected an instance
    # they can control.
    #
    return if ( !isControlling() );

    my $ret=(tied $ACTIVE)->connector->uptime;
	print $ret;
}



=begin doc

  Show the user the version of this shell, and of the Xen software installed.

=end doc

=cut

sub do_version
{
    if ( $CONFIG{ 'banner' } )
    {
        print $CONFIG{ 'banner' } . "\n";
    }
    else
    {
        print "cloud-shell v$RELEASE";
    }
    print "\n";
}



=begin doc

  Show the username of the currently connected user.

=end doc

=cut

sub do_whoami
{
    #print $USER . "\n";
    my $d=(tied $ACTIVE)->connector->vm->data;
	print Dumper $d;
	return $d;
}

sub do_setpref
{
    #my ($args) = (@_);
	my ($var, $val) = @_;

    #if ( !defined($args) || ( !length($args) ) )
    if ( !defined($var) || ( !defined($val) ) )
    {
print <<EOF;
Set configuration variables.
Documentation forthcoming...
EOF
		return;
    }

    #
    #  We have an agument.  Assume it is of the form:
    #
    #  set [var] [val]
	#  also allowing
	#  set var=val
	#  set var:val
    #
    #my ( $var, $val ) = split( /[ :=\t]/, $args, 2 );

	unless (defined($val)) {
		print "No value specified.\n";
		return;
	}

	my @allowedvars=(
		'autoheal',
		'cpu_arch',
		'boot_method',
		'disk_namespace',
		'interactive_shell'
	);
	my %avarhash;
	@avarhash{@allowedvars}=();
	if (exists $avarhash{$var}) {
		(tied $ACTIVE)->vm->setuvar($var, $val);
	} else {
		print "Illegal variable specified.\n";
	}
}

sub do_getpref
{
	my $pref=(tied $ACTIVE)->vm->getuvar();
	print Dumper $pref;
}

sub do_fetch
{
	use LWP::Simple;
	my $uri=shift;
	my (
		undef,
		$length,
		undef,
		undef,
		undef
	)=head($uri);

	return -2 if ( ! defined($length) );
	return -1 if ($length > 2048);
	return get($uri);
}


#
#  Print a newline or two on termination, just to make things prettier.
#
END
{
    print "\n\n";
}


####
#
#  Start of code
#
####

sub main {
	#
	# Find the username and homedir of the user who invoked this script.
	# EricW: Changed $REAL_USER_ID to $< as this worked on my systems.
	#
	my @UENT = getpwuid($<);
	our $USER = $UENT[0];
	our $HOME = $UENT[7];

	# For security, we sanity-check the $HOME variable.
	for ($HOME) {
		if (/^\s*$/ || /\.\./ || /^[^\/]/) {
			die "Bad HOME: ".$HOME."\n"; # Bad wolf... blowing down my $HOME
		}
	};

	#
	# Sanity check our host and user.
	#
	sanityCheck();

	#
	#  Remove commands the user can't access - either because the supporting
	# software is not present, or because they've been globally disabled.
	#
	removeCommands();

	#
	# Show our banner.
	#
	showBanner();

	#
	#  If the user specified an initial machine to control then use it,
	# if possible.
	#
	$ACTIVE = $CONFIG{ 'control' }
	  if ( defined( $CONFIG{ 'control' } ) &&
		   canControl( $CONFIG{ 'control' } ) );

	#
	#  Setup a signal handler to make sure we save history at exit-time.
	#
	$SIG{ INT } = "do_exit";

	#
	#
	#  Create the readline interface.
	#
	my $term = createTerminal();

	#
	#  Load any command history which might be present.
	#
	loadHistory($term);

	#
	#  Run our command loop - note this never returns.
	#
	runMainLoop($term);

	#
	#  Never reached
	#
	exit;
}

=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

 Eric
 --
 http://www.grokthis.net/

=cut


=head1 LICENSE

xen-shell Copyright (c) 2005-2007 by Steve Kemp.  All rights reserved.
cloud-shell (c) 2006-2010 by Eric Windisch. All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut

1;
